var fs = require('fs');
var shelljs = require('shelljs');
var gulp = require('gulp');
var packJson = JSON.parse(fs.readFileSync('./package.json'));
var isReleaseBranch = /^((release\/))/g.test(process.env.BRANCH_NAME);
var isHotfixBranch = /^((hotfix\/))/g.test(process.env.BRANCH_NAME);
var publishSettingsPath = __dirname + '/../sfblazor.PublishSettings';
const read = require("fs-readdir-recursive");
var publish = require('./publish');
var targetBranch;

gulp.task('blazor-showcase-azure-publish', function (done) {
    blazorBuild("publish", done);
});

gulp.task('blazor-showcase-build', function (done) {
    targetBranch = process.argv[4];
    blazorBuild("build", done);
});

gulp.task('blazor-sb-publish', function (done) {
    fs.writeFileSync('./App_Offline.htm', fs.readFileSync(__dirname + '/template/App_Offline.template', 'utf-8'), 'utf-8');
    var path = isHotfixBranch ? 'site/hotfix' : 'site/development';
    path = isReleaseBranch ? 'site/release' : path;
    path = path + '/blazordemos/';
    var sampleList = ['BlazorServerApp', 'BlazorServerApp_NET6', 'BlazorWasmApp_NET6'];
    publish.deployFolder(publishSettingsPath, sampleList, path, done);
});

function blazorBuild(type, done) {
    var projects = read("./").filter(item => item.endsWith(".csproj"));
    projects = checkWasmHosted(projects, type);
    for (var i = 0; i < projects.length; i++) {
        var projType = fs.readFileSync('./' + projects[i], 'utf8');
        var appType = "server";
        if (projType.indexOf("Microsoft.NET.Sdk.BlazorWebAssembly") > 0) {
            appType = "wasm";
        }
        if(projType.indexOf("Microsoft.NET.Sdk.Razor") > 0 && projType.indexOf("<UseMaui>true</UseMaui>") > 0){
            console.log("Currently, we didn't provide the CI support for Blazor MAUI application....Please ensure it in local machine");
            appType = "maui";
        }
        if(appType !== 'maui'){
            if (type === 'build') {
                showcaseBuild(projects[i], appType);
            } else {
                shipFolder(appType, packJson.name);
            }
        }
    }
    done();
}

function checkWasmHosted(projects, type) {
    const hosted = [];
    var isHosted = "false";
    hosted.push(projects.filter(item => item.endsWith(".Client.csproj")).toString());
    hosted.push(projects.filter(item => item.endsWith(".Server.csproj")).toString());
    hosted.push(projects.filter(item => item.endsWith(".Shared.csproj")).toString());
    if (hosted.length === 3) {
        for (var i = 0; i < hosted.length; i++) {
            if (projects.indexOf(hosted[i]) > -1) {
                projects.splice(projects.indexOf(hosted[i]), 1);
                isHosted = "true";
            }
        }
        if(isHosted === "true"){
            if (type === "build") {
                showcaseBuild(hosted.filter(item => item.endsWith(".Server.csproj"))[0], "wasm-hosted");
            } else {
                shipFolder('wasm-hosted', packJson.name);
            }
        }
    }
    return projects;
}

function getTargetNugetFeed() {
    // In nexus there is no location for blazor-production. So we disable the below line
    // var tBranch = targetBranch === 'master'? 'blazor-production/' :'blazor-development/';
    var tBranch = 'blazor-development/';
    tBranch = /^((hotfix\/))/g.test(targetBranch) ? 'blazor-hotfix/' : tBranch;
    tBranch = /^((release\/))/g.test(targetBranch) ? 'blazor-release/' : tBranch;
    return tBranch;
}

function showcaseBuild(project, type) {
    if (project != undefined && fs.existsSync('./' + project)) {
        var nugetFeed = getTargetNugetFeed();
        console.log("Nuget Feed: source -> https://nexus.syncfusion.com/repository/" + nugetFeed + " Feedname -> nexus-staging" );
        var addDevOpsFeed = shelljs.exec('dotnet nuget add source https://nexus.syncfusion.com/repository/'+ nugetFeed +' -n nexus-staging', { silent: false });
        var restore = shelljs.exec('dotnet restore ./' + project, { silent: false });
        var publish = shelljs.exec('dotnet publish ./' + project + ' -c Release -o ' + type + ' --no-restore', { silent: false });
        var resetFeed = shelljs.exec('dotnet nuget remove source nexus-staging', { silent: false });
        if (restore.code !== 0 || publish.code !== 0 || addDevOpsFeed.code !== 0 || resetFeed.code !== 0) {
            process.exit(1);
        }
    }
}

function updatebaseHref(platform, base) {
    var basePath = base.split('/');
    // Remove the 'site' from path
    basePath.shift();
    basePath = '/' + basePath[0] + '/' + basePath[1] + '/' + basePath[2] + '/' + platform + '/';
    if ((platform === 'wasm' || platform === 'wasm-hosted') && fs.existsSync('./' + platform + '/wwwroot/index.html')) {
        var baseHref;
        var index = fs.readFileSync('./' + platform + '/wwwroot/index.html', 'utf8');
        var defHref = index.match(/\<base href(.*) \/>/g);
        baseHref = '<base href="' + basePath + '" />';
        index = index.replace(defHref[0], baseHref);
        fs.writeFileSync('./' + platform + '/wwwroot/index.html', index);
        console.log("WebAssembly - Application's published location - " + 'https://sfblazor.azurewebsites.net' + basePath);
    }
    else if(platform === 'server' && fs.existsSync('./' + platform + '/web.config')){
        var webConfig = fs.readFileSync('./' + platform + '/web.config', 'utf8');
        webConfig = webConfig.replace('modules="AspNetCoreModuleV2"', 'modules="AspNetCoreModule"');
        fs.writeFileSync('./' + platform + '/web.config', webConfig);
        console.log("Server - Application's published location - " + 'https://sfblazor.azurewebsites.net' + basePath);
    }
}

function shipFolder(platform, appName) {
    fs.writeFileSync('./App_Offline.htm', fs.readFileSync(__dirname + '/template/App_Offline.template', 'utf-8'), 'utf-8');
    var branchName = process.env.BRANCH_NAME;
    var path = branchName === 'master' ? 'site/production' : 'site/development';
    path = isReleaseBranch ? 'site/release' : path;
    path = isHotfixBranch ? 'site/hotfix' : path;
    path = path + '/showcase/' + appName;
    updatebaseHref(platform, path);
    publish.deployFolder(publishSettingsPath, platform.split(), path);
}
