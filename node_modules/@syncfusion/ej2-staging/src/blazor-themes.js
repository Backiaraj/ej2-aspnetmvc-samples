var fs = require('fs');
var shelljs = require('shelljs');
var gulp = require('gulp');
var glob = require('glob');
var simpleGit = require('simple-git');
var runSequence = require('run-sequence');
const THEME_CONFIG = fs.existsSync('./config.json') ? JSON.parse(fs.readFileSync('./config.json')) : {};
const isReleaseBranch = /^(release\/)/g.test(process.env.BRANCH_NAME);
const isHotfixBranch = /^(hotfix\/)/g.test(process.env.BRANCH_NAME);

// Task to generate individual SCSS files in component wise for Blazor.
gulp.task('individual-scss', function () {
    var individualCompDeps = getIndividualCompDeps();
    // Get the all themes defintion files in components folder
    var getFiles = glob.sync('./styles/**/_*-definition.scss', { ignore: './styles/barcode-generator/**/*.scss' });
    if (fs.existsSync('./SCSS-Themes')) {
        shelljs.rm('-rf', './SCSS-Themes');
    }
    shelljs.mkdir('-p', './SCSS-Themes/');
    for (var getFile of getFiles) {
        var component = getFile.split('/')[2];
        var subComponent = getFile.split('/')[3];
        if (component === 'base') {
            var definitionFile = fs.readFileSync(getFile.replace(subComponent, 'definition/') + subComponent.replace('-definition', ''), 'utf8').trim();
            var rootDefinition = fs.readFileSync(getFile, 'utf8');
            definitionFile += '\n' + rootDefinition;
            var themeName = getFile.split('/')[3].replace('-definition', '').replace('_', '');
            // Get the inner level scss files (e.g., - mixin, layout)
            var combineScss = glob.sync('./styles/' + component + '/**' + '/_*.scss', { ignore: ['./styles/' + component + '/_all.scss', './styles/' + component + '/**' + '/_*-definition.scss', './styles/' + component + '/common' + '/_all.scss', './styles/' + component + '/definition' + '/_*.scss'] });
            for (var combine of combineScss.reverse()) {
                var readSub = fs.readFileSync(combine, 'utf8');
                definitionFile += '\n' + readSub + '\n';
            }
            var baseIcons = (themeName.indexOf('-dark') !== -1 || themeName.indexOf('-light') !== -1) ? themeName.split('-')[0] + '.scss' : themeName;
            var readIcons = fs.readFileSync('./styles/icons/' + baseIcons, 'utf8');
            // Add the icons in base definition file
            var iconDefinition = `@include export-module('base-icons') {\n` + readIcons + `\n}`;
            definitionFile += '\n' + iconDefinition;
            var regex = new RegExp('@import \'(.*).scss\';', 'g');
            var importedStyles = definitionFile.match(regex);
            if (importedStyles) {
                for (var importedStyle of importedStyles) {
                    definitionFile = definitionFile.replace(importedStyle, '');
                }
            }
            definitionFile = definitionFile.replace(/﻿/g, '');
            shelljs.cd('./SCSS-Themes/');
            shelljs.mkdir('-p', component);
            // Write the styles content in created folder
            if (THEME_CONFIG.themes.indexOf(themeName.replace('.scss', '')) !== -1) {
                fs.writeFileSync(process.cwd() + '/' + component + '/' + themeName, definitionFile, 'utf8');
            }
            shelljs.cd('../');
        }
        // Ignoring spreadsheet control themes conditionally for Blazor. 
        else if (component !== 'spreadsheet') {
            var scssContent = '';
            var definitionFile = fs.readFileSync(getFile, 'utf8');
            // Get theme name
            var themeName = getFile.split('/')[4].replace('-definition', '').replace('_', '');
            // Get the all scss files in components folder
            var combineScss = glob.sync('./styles/' + component + '/' + subComponent + '/**/_*.scss',
                {
                    ignore: ['./styles/' + component + '/' + subComponent + '/_*-definition.scss',
                    './styles/' + component + '/' + subComponent + '/_all.scss',
                    './styles/' + component + '/' + subComponent + '/_definition.scss',
                    './styles/' + component + '/' + subComponent + '/_icons.scss']
                });
            for (var combine of combineScss) {
                if (combine.indexOf('/icons/') !== -1) {
                    if (combine.split('/')[5] === '_' + themeName) {
                        var readSub = fs.readFileSync(combine, 'utf8');
                        definitionFile += '\n' + readSub + '\n';
                    }
                }
                else {
                    var readSub = fs.readFileSync(combine, 'utf8');
                    definitionFile += '\n' + readSub + '\n';
                }
            }
            var regex = new RegExp('@import \'(.*).scss\';', 'g');
            // Match any import content and remove that content
            var importedStyles = definitionFile.match(regex);
            if (importedStyles) {
                for (var importedStyle of importedStyles) {
                    definitionFile = definitionFile.replace(importedStyle, '');
                }
            }
            definitionFile = definitionFile.replace(/﻿/g, '');
            shelljs.cd('./SCSS-Themes/');
            // create the components folder (e.g., - buttons/button)
            shelljs.mkdir('-p', component + '/' + subComponent);
            // Write the styles content in created folder
            if (THEME_CONFIG.themes.indexOf(themeName.replace('.scss', '')) !== -1) {
                var importContent = getImportcontent(individualCompDeps, subComponent, themeName);
                scssContent = definitionFile.indexOf(`@use 'sass:math';`) !== -1 ? `@use 'sass:math';\n` + importContent + definitionFile.replace(`@use 'sass:math';`, '') : importContent + definitionFile;
                fs.writeFileSync(process.cwd() + '/' + component + '/' + subComponent + '/' + themeName, scssContent);
            }
            // Adding dark theme for components
            if (THEME_CONFIG.themes.indexOf(themeName.replace('.scss', '')) !== -1 && THEME_CONFIG.new_themes.indexOf(themeName.split('.')[0]) !== -1) {
                var importContent = getImportcontent(individualCompDeps, subComponent, themeName.split('.')[0] + '-dark.scss');
                scssContent = definitionFile.indexOf(`@use 'sass:math';`) !== -1 ? `@use 'sass:math';\n` + importContent + definitionFile.replace(`@use 'sass:math';`, '') : importContent + definitionFile;
                fs.writeFileSync(process.cwd() + '/' + component + '/' + subComponent + '/' + themeName.split('.')[0] + '-dark.scss', scssContent);
            }
            shelljs.cd('../');
        }
    }
});

// Task to generate single SCSS files for Blazor.
gulp.task('combined-scss', function () {
    var themes = THEME_CONFIG.themes;
    for (var theme of themes) {
        // Get the all components scss files with respective theme name
        var componentFiles = glob.sync('./SCSS-Themes/**/' + theme + '.scss', { ignore: './SCSS-Themes/**/definition/*.scss' });
        var getScss = '';
        // Place component styles as per styles order
        for (var themeOrder of THEME_CONFIG.componentThemeOrder) {
            var paths = componentFiles.filter((value) => { return value.indexOf('/' + themeOrder + '/' + theme) !== -1; });
            if (paths.length) {
                getScss += fs.readFileSync(paths[0], 'utf8');
            }
        }
        getScss = getScss.replace(/@import \'(.*).scss\';/g, '');
        fs.writeFileSync('./SCSS-Themes/' + theme + '.scss', `@use 'sass:math';\n` + getScss, 'utf8');
    }
});

gulp.task('publish-themes', async function () {
    var blazorThemes = 'Blazor-Themes';
    // Create package.json and README content from template files to publish the NPM package
    var packageJson = fs.readFileSync(__dirname + '/template/blazor-themes-packagejson.template', 'utf-8');
    var readme = fs.readFileSync(__dirname + '/template/blazor-themes-readme.template', 'utf-8');
    shelljs.mkdir('-p', blazorThemes);
    shelljs.mv('-f', 'SCSS-Themes/', blazorThemes);
    fs.writeFileSync(`./${blazorThemes}/package.json`, packageJson, 'utf-8');
    fs.writeFileSync(`./${blazorThemes}/README.md`, readme, 'utf-8');

    // Clone the Blazor release automation repo.
    var branchFolder = isHotfixBranch ? 'hotfix' : 'development';
    branchFolder = isReleaseBranch ? 'release' : branchFolder;
    var checkoutBranch = 'release-automation';
    var targetRepo = `https://SyncfusionBuild:${process.env.GithubBuildAutomation_PrivateToken}@github.com/essential-studio/blazor-release-automation.git`;
    var checkout = shelljs.exec(`git clone ${targetRepo} -b master ${checkoutBranch}`, { silent: true });
    if (checkout.code !== 0) {
        console.log('Blazor release automation repo checkout has been failed.');
        process.exit(1);
    }

    // Copy the generated SCSS files to Blazor release automation
    if (fs.existsSync(`./${checkoutBranch}/Blazor-SCSS-Themes/${branchFolder}`)) {
        shelljs.rm('-rf', `./${checkoutBranch}/Blazor-SCSS-Themes/${branchFolder}`);
    }
    fs.mkdirSync(`./${checkoutBranch}/Blazor-SCSS-Themes/${branchFolder}`, { recursive: true });
    shelljs.cp('-r', blazorThemes + '/', `./${checkoutBranch}/Blazor-SCSS-Themes/${branchFolder}`);
    shelljs.cd(checkoutBranch);

    // Commit the generated SCSS changes to Blazor release automation.
    await simpleGit('').init().add('.').commit('config(BLAZ-000): Latest Blazor SCSS files has been shipped').push(targetRepo, 'master', () => {
        console.log('Blazor SCSS files are committed to Blazor Release Automation.');
        shelljs.cd('../');
        shelljs.rm('-rf', checkoutBranch);
    });

    // Process to publish the NPM package to nexus.
    var repoName = isHotfixBranch ? 'ej2-hotfix-new' : 'ej2-development';
    repoName = isReleaseBranch ? 'ej2-release' : repoName;
    var registry = '//nexus.syncfusion.com/repository/' + repoName + '/'
    var npmrcContent = `registry=https://registry.npmjs.org/
@syncfusion:registry=http:${registry}
${registry}:username=${process.env.PRIVATE_NPM_USER}
${registry}:_password=${process.env.PRIVATE_NPM_PASSWORD}
${registry}:email=${process.env.PRIVATE_NPM_EMAIL}
${registry}:always-auth=true
`;
    shelljs.cd(blazorThemes);
    fs.writeFileSync('./.npmrc', npmrcContent);
    shelljs.exec('npm publish --access=public');
});

// Combining gulp task to generate and publish the blazor themes in sequence.
gulp.task('blazor-themes', function () {
    runSequence('individual-scss', 'combined-scss', 'publish-themes');
});

// Function to get all the component style dependency to add import stattement.
function getIndividualCompDeps() {
    var individualDeps = {};
    var stylesJson = getStyleJson();
    for (var control of Object.keys(stylesJson)) {
        if (stylesJson[control][0] === 'e' || control === 'data-grid') {
            continue;
        } else {
            var controlDeps = Object.keys(stylesJson[control]);
            if (controlDeps.length) {
                for (var dependency of controlDeps) {
                    individualDeps[dependency] = dependencyList(['base'], updateControlsInfo(dependency, control, { fullPackages: [], packageControls: {} }, stylesJson));
                }
            }
        }
    }
    return individualDeps;
}

// Function to get all the component styles dependencies as JSON format.
function getStyleJson() {
    var style = JSON.parse(fs.readFileSync('./src/wwwroot/ej2-resource/styles.json', 'utf-8'));
    var packs = Object.keys(style);
    var tStyle = {};
    var compName = "";
    for (var pack of packs) {
        for (var comp of style[pack]) {
            if (!tStyle[pack]) {
                tStyle[pack] = {};
            }
            compName = Object.keys(comp)[0];
            tStyle[pack][compName] = comp[compName];
        }
    }
    return tStyle;
}

// Gets the component dependent styles upto its nth level.
function updateControlsInfo(control, package, controlsInfo, styles) {
    var dependencies = [];
    if (controlsInfo.fullPackages.indexOf(package) === -1) {
        if (!controlsInfo.packageControls[package]) {
            controlsInfo.packageControls[package] = [];
        }
        if (controlsInfo.packageControls[package].indexOf(control) === -1) {
            controlsInfo.packageControls[package].push(control);
            if (styles[package]) {
                dependencies = styles[package][control];
                if (dependencies ? dependencies.length : false) {
                    controlsInfo = getStyleDependencies(dependencies, styles, controlsInfo, package);
                }
            }
        }
    }
    return controlsInfo;
}

// Returns the style dependencies with specified format.
function getStyleDependencies(dependencies, styles, controlsInfo, packageName) {
    var package = '';
    var controlName = '';
    for (var dependency of dependencies) {
        var depSplit = dependency.split('/');
        if (depSplit[0].indexOf('ej2-') !== -1) {
            if (depSplit.length === 2) {
                package = getPackageName(depSplit[0]);
                controlName = depSplit[1];
                controlsInfo = updateControlsInfo(controlName, package, controlsInfo, styles);
            } else if (depSplit.length === 1) {
                package = getPackageName(dependency);
                var controls = styles[package] ? Object.keys(styles[package]) : [];
                for (var control of controls) {
                    controlsInfo = updateControlsInfo(control, package, controlsInfo, styles);
                }
                controlsInfo.fullPackages.push(package);
            }
        } else if (dependency.indexOf('../') !== -1) {
            controlName = dependency.replace(/(\.\/\.\.\/)|(\.\.\/)/, '');
            controlsInfo = updateControlsInfo(controlName, packageName, controlsInfo, styles);
        }
    }
    return controlsInfo;
}

// Returns package name for dependency ordering.
function getPackageName(input) {
    return input.replace(/(ej2-|-)/g, '');
}

// Iterate the dependency list by package wise and return the dependencies by component wise.
function dependencyList(controlDependencies, controlsInfo) {
    var packages = Object.keys(controlsInfo.packageControls);
    for (var package of packages) {
        for (var control of controlsInfo.packageControls[package]) {
            controlDependencies.push(package + '/' + control);
        }
    }

    return controlDependencies;
}

// Function to return the styles dependency import statement base on component.
function getImportcontent(individualCompDeps, component, themeName) {
    var importContent = '';
    for (var componentTheme of THEME_CONFIG.componentThemeOrder) {
        if (individualCompDeps[component] && individualCompDeps[component].indexOf(componentTheme) !== -1 && !componentTheme.endsWith(component)) {
            importContent += `@import '../../${componentTheme}/${themeName}';\n`;
        }
    }
    return importContent;
}
